{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/constants.js"],"sourcesContent":["'use strict';\n\n/**\n * @enum {number}\n */\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7,\n};\n\n/**\n * @enum {number}\n */\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  SET: 258,\n};\n\n/**\n * @enum {number}\n */\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31,\n};\n\n/**\n * @enum {number}\n */\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23,\n};\n\nexports.SYMS = {\n  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),\n  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),\n  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),\n  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),\n  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),\n};\n\nexports.SHIFT32 = 0x100000000;\n\nexports.BI = {\n  MINUS_ONE: BigInt(-1),\n  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),\n  MAXINT32: BigInt('0xffffffff'),\n  MAXINT64: BigInt('0xffffffffffffffff'),\n  SHIFT32: BigInt(exports.SHIFT32),\n};\n\n"],"names":[],"mappings":"AAEA;;CAEC,GACD,QAAQ,EAAE,GAAG;IACX,SAAS;IACT,SAAS;IACT,aAAa;IACb,aAAa;IACb,OAAO;IACP,KAAK;IACL,KAAK;IACL,cAAc;AAChB;AAEA;;CAEC,GACD,QAAQ,GAAG,GAAG;IACZ,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,UAAU;IACV,oBAAoB;IACpB,iBAAiB;IACjB,iBAAiB;IACjB,MAAM;IACN,KAAK;IACL,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,6EAA6E;IAC7E,KAAK;AACP;AAEA;;CAEC,GACD,QAAQ,QAAQ,GAAG;IACjB,MAAM;IACN,KAAK;IACL,KAAK;IACL,MAAM;IACN,OAAO;IACP,YAAY;AACd;AAEA;;CAEC,GACD,QAAQ,MAAM,GAAG;IACf,OAAO;IACP,MAAM;IACN,MAAM;IACN,WAAW;AACb;AAEA,QAAQ,IAAI,GAAG;IACb,MAAM,OAAO,GAAG,CAAC;IACjB,WAAW,OAAO,GAAG,CAAC;IACtB,QAAQ,OAAO,GAAG,CAAC;IACnB,OAAO,OAAO,GAAG,CAAC;IAClB,QAAQ,OAAO,GAAG,CAAC;AACrB;AAEA,QAAQ,OAAO,GAAG;AAElB,QAAQ,EAAE,GAAG;IACX,WAAW,OAAO,CAAC;IACnB,SAAS,OAAO,CAAC,KAAK,OAAO,OAAO,gBAAgB;IACpD,UAAU,OAAO;IACjB,UAAU,OAAO;IACjB,SAAS,OAAO,QAAQ,OAAO;AACjC","ignoreList":[0]}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/utils.js"],"sourcesContent":["'use strict';\n\nconst {Buffer} = require('buffer');\nconst NoFilter = require('nofilter');\nconst stream = require('stream');\nconst constants = require('./constants');\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants;\nconst MAX_SAFE_HIGH = 0x1fffff;\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true});\nexports.utf8 = buf => td.decode(buf);\nexports.utf8.checksUTF8 = true;\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true;\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function');\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView));\n};\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b;\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength);\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b);\n  }\n  return null;\n};\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0);\n      const g = buf.readUInt32BE(4);\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g);\n      }\n      return (f * SHIFT32) + g;\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`);\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0);\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000; // Top bit is sign\n  const exp = (u >> 23) & 0xff; // Then 5 bits of exponent\n  const mant = u & 0x7fffff;\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13);\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false;\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp));\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false;\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16);\n  return true;\n};\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1;\n  const exp = (buf[0] & 0x7C) >> 2;\n  const mant = ((buf[0] & 0x03) << 8) | buf[1];\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity);\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant);\n};\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n    case 4:\n      return buf.readFloatBE(0);\n    case 8:\n      return buf.readDoubleBE(0);\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`);\n  }\n};\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  let start = 0;\n  let end = (s.length % 8) || 8;\n  const chunks = [];\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n  return Buffer.from(chunks);\n};\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true;\n  }\n  if ((a == null) || (b == null)) {\n    return false;\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i]);\n};\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`);\n};\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null';\n        case SYMS.UNDEFINED:\n          return 'undefined';\n        case SYMS.BREAK:\n          return 'BREAK';\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description;\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString();\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/);\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name;\n      }\n      return 'Symbol';\n    }\n    case 'string':\n      return JSON.stringify(val);\n    case 'bigint':\n      return val.toString();\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val);\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s;\n    }\n    case 'object': {\n      if (!val) {\n        return 'null';\n      }\n      const buf = exports.bufferishToBuffer(val);\n      if (buf) {\n        const hex = buf.toString('hex');\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`;\n      }\n      if (val && typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]();\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]';\n      }\n      // This should be all that is left\n      return '{}';\n    }\n  }\n  return String(val);\n};\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding);\n  }\n  const buf = exports.bufferishToBuffer(input);\n  if (buf) {\n    return new NoFilter(buf);\n  }\n  if (isReadable(input)) {\n    return input;\n  }\n  throw new Error('Unknown input type');\n};\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n};\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c]);\n};\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64');\n};\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/vendor/binary-parse-stream/index.js"],"sourcesContent":["// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict';\n// eslint-disable-next-line n/prefer-node-protocol\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options);\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false;\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true;\n\n    this.bs = new NoFilter();\n    this.__restart();\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} _encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, _encoding, cb) {\n    this.bs.write(fresh);\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null;\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed);\n\n      try {\n        ret = this.__parser.next(chunk);\n      } catch (e) {\n        return cb(e);\n      }\n\n      if (this.__needed) {\n        this.__fresh = false;\n      }\n\n      if (ret.done) {\n        this.push(ret.value);\n        this.__restart();\n      } else {\n        this.__needed = ret.value || Infinity;\n      }\n    }\n\n    return cb();\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass');\n  }\n\n  __restart() {\n    this.__needed = null;\n    this.__parser = this._parse();\n    this.__fresh = true;\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'));\n  }\n}\n\nmodule.exports = BinaryParseStream;\n"],"names":[],"mappings":"AAAA,mDAAmD;AACnD,uDAAuD;AACvD,kEAAkE;AAClE,uDAAuD;AACvD,uCAAuC;AAEvC,qEAAqE;AACrE,uDAAuD;AAGvD,kDAAkD;AAClD,MAAM;AACN,MAAM;AAEN;;;;;;;;CAQC,GACD,MAAM,0BAA0B,OAAO,SAAS;IAC9C;;;;;GAKC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;QACN,yDAAyD;QACzD,qEAAqE;QACrE,wCAAwC;QACxC,IAAI,CAAC,iBAAiB,CAAC,UAAU,GAAG;QACpC,wCAAwC;QACxC,IAAI,CAAC,iBAAiB,CAAC,UAAU,GAAG;QAEpC,IAAI,CAAC,EAAE,GAAG,IAAI;QACd,IAAI,CAAC,SAAS;IAChB;IAEA;;;;;;;GAOC,GACD,WAAW,KAAK,EAAE,SAAS,EAAE,EAAE,EAAE;QAC/B,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;QAEd,MAAO,IAAI,CAAC,EAAE,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAE;YACtC,IAAI,MAAM;YACV,MAAM,QAAQ,AAAC,IAAI,CAAC,QAAQ,KAAK,OAC/B,YACA,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ;YAE5B,IAAI;gBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;YAC3B,EAAE,OAAO,GAAG;gBACV,OAAO,GAAG;YACZ;YAEA,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,IAAI,CAAC,OAAO,GAAG;YACjB;YAEA,IAAI,IAAI,IAAI,EAAE;gBACZ,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK;gBACnB,IAAI,CAAC,SAAS;YAChB,OAAO;gBACL,IAAI,CAAC,QAAQ,GAAG,IAAI,KAAK,IAAI;YAC/B;QACF;QAEA,OAAO;IACT;IAEA;;;;;;GAMC,GACD,wBAAwB,GACxB,CAAC,SAAS;QACR,MAAM,IAAI,MAAM;IAClB;IAEA,YAAY;QACV,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM;QAC3B,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA;;;;;GAKC,GACD,OAAO,EAAE,EAAE;QACT,GAAG,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,MAAM;IACrC;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 440, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/tagged.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON');\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn;\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn);\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn);\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this);\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this);\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex');\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab);\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size];\n\n  const end = byteOffset + byteLength;\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true));\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis;\n    } else {\n      setBuffersToJSON(v, b64urlThis);\n    }\n    return tag;\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this;\n    } else {\n      setBuffersToJSON(v, b64this);\n    }\n    return tag;\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis;\n    } else {\n      setBuffersToJSON(v, hexThis);\n    }\n    return tag;\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters');\n    }\n    const last = v.length % 4;\n    if (last === 1) {\n      throw new Error('Invalid base64url length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag;\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/);\n    if (!m) {\n      throw new Error('Invalid base64 characters');\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length');\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding');\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag;\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n};\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n};\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array;\n  TYPED_ARRAY_TAGS[71] = BigUint64Array;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array;\n  TYPED_ARRAY_TAGS[79] = BigInt64Array;\n}\n\nfunction toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer');\n  }\n  const {tag} = tagged;\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag];\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`);\n  }\n  const little = tag & 0b00000100;\n  const float = (tag & 0b00010000) >> 4;\n  const sz = 2 ** (float + (tag & 0b00000011));\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);\n  return new TypedClass(ab);\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = toTypedArray;\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {};\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`);\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`);\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value);\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    };\n    if (this.err) {\n      ret.err = this.err;\n    }\n    return ret;\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n    return gen.pushAny(this.value);\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag];\n    if (f === null) { // === is intentional. null has semantic meaning as above\n      return this;\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag];\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n    try {\n      return f.call(this, this.value, this);\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message;\n      } else {\n        this.err = error;\n      }\n      return this;\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS;\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val;\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS};\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON;\nTagged.reset();\nmodule.exports = Tagged;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 791, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/simple.js"],"sourcesContent":["'use strict';\n\nconst {MT, SIMPLE, SYMS} = require('./constants');\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`);\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} _depth How deep are we?\n   * @param {object} _opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](_depth, _opts) {\n    return `simple(${this.value})`;\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple;\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false;\n      case SIMPLE.TRUE:\n        return true;\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null;\n        }\n        return SYMS.NULL;\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined;\n        }\n        return SYMS.UNDEFINED;\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK');\n        }\n        return SYMS.BREAK;\n      default:\n        return new Simple(val);\n    }\n  }\n}\n\nmodule.exports = Simple;\n"],"names":[],"mappings":"AAEA,MAAM,EAAC,EAAE,EAAE,MAAM,EAAE,IAAI,EAAC;AAExB;;CAEC,GACD,MAAM;IACJ;;;;GAIC,GACD,YAAY,KAAK,CAAE;QACjB,IAAI,OAAO,UAAU,UAAU;YAC7B,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,OAAO;QACxD;QACA,IAAI,AAAC,QAAQ,KAAO,QAAQ,OAAS,CAAC,QAAQ,CAAC,MAAM,OAAQ;YAC3D,MAAM,IAAI,MAAM,CAAC,wCAAwC,EAAE,OAAO;QACpE;QACA,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;;;GAIC,GACD,WAAW;QACT,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAChC;IAEA;;;;;;GAMC,GACD,CAAC,OAAO,GAAG,CAAC,8BAA8B,CAAC,MAAM,EAAE,KAAK,EAAE;QACxD,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IAChC;IAEA;;;;;GAKC,GACD,WAAW,GAAG,EAAE;QACd,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,YAAY;IACjD;IAEA;;;;;GAKC,GACD,OAAO,SAAS,GAAG,EAAE;QACnB,OAAO,eAAe;IACxB;IAEA;;;;;;;;;;;;GAYC,GACD,OAAO,OAAO,GAAG,EAAE,aAAa,IAAI,EAAE,oBAAoB,KAAK,EAAE;QAC/D,OAAQ;YACN,KAAK,OAAO,KAAK;gBACf,OAAO;YACT,KAAK,OAAO,IAAI;gBACd,OAAO;YACT,KAAK,OAAO,IAAI;gBACd,IAAI,YAAY;oBACd,OAAO;gBACT;gBACA,OAAO,KAAK,IAAI;YAClB,KAAK,OAAO,SAAS;gBACnB,IAAI,YAAY;oBACd,OAAO;gBACT;gBACA,OAAO,KAAK,SAAS;YACvB,KAAK,CAAC;gBACJ,IAAI,CAAC,cAAc,CAAC,mBAAmB;oBACrC,MAAM,IAAI,MAAM;gBAClB;gBACA,OAAO,KAAK,KAAK;YACnB;gBACE,OAAO,IAAI,OAAO;QACtB;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 883, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/decoder.js"],"sourcesContent":["'use strict';\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\nconst Tagged = require('./tagged');\nconst Simple = require('./simple');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst constants = require('./constants');\nconst {MT, NUMBYTES, SYMS, BI} = constants;\nconst {Buffer} = require('buffer');\n\nconst COUNT = Symbol('count');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`);\n    this.name = 'UnexpectedDataError';\n    this.byte = byte;\n    this.value = value;\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView\n *   |DataView|import('stream').Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferMap=false] If true, prefer to generate Map\n *   instances to plain objects, even if there are no entries in the map\n *   or if all of the keys are strings.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferMap = false,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options;\n\n    super({defaultEncoding: encoding, ...superOpts});\n\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    this.preferMap = preferMap;\n    this.preferWeb = preferWeb;\n    this.extendedResults = extendedResults;\n    this.required = required;\n    this.preventDuplicateKeys = preventDuplicateKeys;\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this));\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter());\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n      case SYMS.UNDEFINED:\n        return undefined;\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found');\n      default:\n        return val;\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options} = normalizeOptions(options));\n    const {encoding = 'hex', ...opts} = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse();\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data');\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b);\n      }\n      state = parser.next(b);\n    }\n\n    let val = null;\n    if (c.extendedResults) {\n      val = state.value;\n      val.unused = s.read();\n    } else {\n      val = Decoder.nullcheck(state.value);\n      if (s.length > 0) {\n        const nextByte = s.read(1);\n\n        s.unshift(nextByte);\n        throw new UnexpectedDataError(nextByte[0], val);\n      }\n    }\n    return val;\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options} = normalizeOptions(options));\n    const {encoding = 'hex', ...opts} = options;\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data');\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b);\n        }\n        state = parser.next(b);\n      }\n      res.push(Decoder.nullcheck(state.value));\n    }\n    return res;\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', required = false, ...opts} = options;\n\n    const c = new Decoder(opts);\n    let v = /** @type {any} */ (NOT_FOUND);\n    const s = utils.guessEncoding(input, encoding);\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice();\n          return resolve(v);\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v;\n        }\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            }\n            return resolve(v);\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined;\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb);\n    }\n    s.pipe(c);\n    return p;\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', ...opts} = options;\n\n    const c = new Decoder(opts);\n    const vals = [];\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)));\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined));\n    }\n    utils.guessEncoding(input, encoding).pipe(c);\n    return p;\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data);\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`);\n      }\n\n      const [octet] = yield 1;\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]));\n        throw new UnexpectedDataError(octet);\n      }\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = (parent == null) ? undefined : parent[MAJOR];\n      const parent_length = (parent == null) ? undefined : parent.length;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          [val] = yield 1;\n          break;\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24);\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf);\n          break;\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error(`Additional info not implemented: ${ai}`);\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n          val = -1;\n          break;\n        default:\n          val = ai;\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break;\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX;\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val;\n          }\n          break;\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              if (mt === MT.UTF8_STRING) {\n                val = '';\n              } else {\n                val = this.preferWeb ?\n                  new Uint8Array(0) :\n                  Buffer.allocUnsafe(0);\n              }\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n              }\n          }\n          break;\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              if (mt === MT.MAP) {\n                val = (this.preferMap) ? new Map() : {};\n              } else {\n                val = [];\n              }\n              break;\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n          break;\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              );\n            }\n            const hasParent = (parent != null);\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            );\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1;\n        } else if (Array.isArray(parent)) {\n          parent.push(val);\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR];\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false;\n            throw new Error('Invalid major type in indefinite encoding');\n          }\n          parent.write(val);\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true;\n          break;\n        }\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n            case MT.MAP: {\n              let allstrings = !this.preferMap;\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`);\n              }\n              for (\n                let i = 0, len = parent.length;\n                allstrings && (i < len);\n                i += 2\n              ) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false;\n                  break;\n                }\n              }\n              if (allstrings) {\n                val = {};\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map');\n                  }\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map');\n                  }\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n              break;\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1]);\n\n              val = t.convert(this.tags);\n              break;\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                );\n              }\n              break;\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n        this.emit('stop', parent[MAJOR]);\n\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice();\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          };\n\n          this.valueBytes = new NoFilter();\n          return ret;\n        }\n        return val;\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1487, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/commented.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst utils = require('./utils');\nconst Decoder = require('./decoder');\nconst NoFilter = require('nofilter');\nconst {MT, NUMBYTES, SYMS} = require('./constants');\nconst {Buffer} = require('buffer');\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  }\n  return '';\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'number':\n      return {options: {max_depth: opts}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    });\n\n    this.depth = depth;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this);\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    });\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this));\n    }\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true});\n\n    c.on('data', b => this.push(b));\n    c.on('error', er => this.emit('error', er));\n    c.end(v);\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const bs = new NoFilter();\n    const {encoding = 'hex', ...opts} = options;\n    const d = new Commented(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ');\n    this.push(er.toString());\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length;\n    if (ind < 1) {\n      ind = 1;\n    }\n    this.push(new Array(ind + 1).join(' '));\n    this.push('-- ');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, _parent_mt, _pos) {\n    let desc = '';\n\n    this.depth++;\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n        break;\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, _parent_mt, _pos) {\n    let desc = '';\n\n    this.depth++;\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`;\n        break;\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`;\n        break;\n    }\n    this.push(`${desc}\\n`);\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `);\n        break;\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `);\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `);\n        }\n        break;\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`);\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item');\n        }\n        break;\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`);\n        }\n        break;\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`);\n        }\n        break;\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n    this.push('\\n');\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(_mt) {\n    this.depth--;\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `);\n          break;\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `);\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `);\n          }\n          break;\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity);\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str);\n        this.push('\\n');\n      }\n      this.depth--;\n    } else {\n      this.push(str);\n      this.push('\\n');\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    this.push('\\n');\n  }\n}\n\nmodule.exports = Commented;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1837, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/diagnose.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Decoder = require('./decoder');\nconst utils = require('./utils');\nconst NoFilter = require('nofilter');\nconst {MT, SYMS} = require('./constants');\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|ArrayBufferView\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)};\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb};\n    case 'object':\n      return {options: opts || {}, cb};\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options;\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    });\n\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    });\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n        return cb();\n      }\n      return cb(er);\n    });\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n    ({options, cb} = normalizeOptions(options, cb));\n    const {encoding = 'hex', ...opts} = options;\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        d.on('error', reject);\n      });\n    }\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString());\n    } else {\n      this.emit('error', er);\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, _parent_mt, _pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len];\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ');\n        }\n        break;\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ');\n          } else {\n            this.push(', ');\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n    this._fore(parent_mt, pos);\n    const fb = this.float_bytes;\n    this.float_bytes = -1;\n    this.push(utils.cborValueToString(val, fb));\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n      case MT.ARRAY:\n        this.push('[');\n        break;\n      case MT.MAP:\n        this.push('{');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ');\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')');\n        break;\n      case MT.ARRAY:\n        this.push(']');\n        break;\n      case MT.MAP:\n        this.push('}');\n        break;\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')');\n        break;\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator);\n  }\n}\n\nmodule.exports = Diagnose;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2084, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/encoder.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst NoFilter = require('nofilter');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants;\nconst {Buffer} = require('buffer');\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO;\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR;\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT;\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE;\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE;\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED;\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL;\n\nconst BREAK = Buffer.from([0xff]);\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {};\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {};\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number';\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number';\n    case 'float':\n      return 'float';\n    case 'int':\n    case 'integer':\n      return 'int';\n    case 'string':\n      return 'string';\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`);\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options;\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    });\n\n    this.canonical = canonical;\n    this.encodeUndefined = encodeUndefined;\n    this.disallowUndefinedKeys = disallowUndefinedKeys;\n    this.dateType = parseDateType(dateType);\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined;\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet();\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops;\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet');\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties;\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES};\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1]);\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v);\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} _encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, _encoding, cb) {\n    const ret = this.pushAny(fresh);\n    // Old transformers might not return bool.  undefined !== false\n    cb((ret === false) ? new Error('Push Error') : undefined);\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb();\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj);\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n    }\n    let max = Number.MAX_SAFE_INTEGER;\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--;\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32);\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    }\n    return this._pushInt(obj, MT.POS_INT);\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN();\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj);\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj);\n    }\n    return this._pushFloat(obj);\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj));\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined);\n        if (buf) {\n          return this.push(buf);\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined);\n  }\n\n  /**\n   * @param {null} _obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(_obj) {\n    return this._pushUInt8(NULL);\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT;\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n\n    let str = obj.toString(16);\n    if (str.length % 2) {\n      str = `0${str}`;\n    }\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf);\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    };\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`);\n        } else {\n          this.detectLoops.add(obj);\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR;\n      if (typeof f === 'function') {\n        return f.call(obj, this);\n      }\n      const converter = this.semanticTypes[obj.constructor.name];\n      if (converter) {\n        return converter.call(obj, this, obj);\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k];\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'));\n    });\n    const cbor_keys = {};\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n\n        return a_cbor.compare(b_cbor);\n      });\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n    let ck = null;\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false;\n        }\n      } else if (!this._pushString(k)) {\n        return false;\n      }\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false;\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj);\n    }\n    return true;\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});\n    this.pipe(bs);\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n    this.end();\n    return bs.read();\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name;\n    const old = this.semanticTypes[typeName];\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function');\n      }\n      this.semanticTypes[typeName] = fun;\n    } else if (old) {\n      delete this.semanticTypes[typeName];\n    }\n    return old;\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n      case 'bigint':\n        return this._pushJSBigint(obj);\n      case 'string':\n        return this._pushString(obj);\n      case 'boolean':\n        return this._pushBoolean(obj);\n      case 'undefined':\n        return this._pushUndefined(obj);\n      case 'object':\n        return this._pushObject(obj);\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined);\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`);\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        );\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    };\n    const len = obj.length;\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false;\n    }\n    this.detectLoops = new WeakSet();\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString());\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000));\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000);\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000);\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()));\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false;\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf());\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    };\n    let entries = [...obj.entries()];\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([_k, v]) => v !== undefined);\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false;\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      });\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark});\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined');\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000;\n    let sz = obj.BYTES_PER_ELEMENT;\n    const {name} = obj.constructor;\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000;\n      sz /= 2;\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000;\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100;\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz];\n    if (!gen._pushTag(typ)) {\n      return false;\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    );\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj));\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode');\n      }\n      obj = this;\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options;\n\n    let ret = true;\n    const objType = typeof obj;\n    let buf = null;\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && gen._pushString(obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE);\n      let offset = 0;\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize;\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex));\n        offset = endIndex;\n      }\n      ret = ret && gen.push(BREAK);\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      });\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      });\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding');\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      });\n    }\n    return ret;\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES;\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val;\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES};\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n});\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;\n}\n\nEncoder.reset();\nmodule.exports = Encoder;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3069, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/map.js"],"sourcesContent":["'use strict';\n\nconst {Buffer} = require('buffer');\nconst encoder = require('./encoder');\nconst decoder = require('./decoder');\nconst {MT} = require('./constants');\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable);\n  }\n\n  /**\n   * @ignore\n   * @param {unknown} key\n   * @returns {string}\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64');\n  }\n\n  /**\n   * @ignore\n   * @param {string} key\n   * @returns {unknown}\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64');\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key));\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val);\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key));\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key));\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @returns {MapIterator<any>}\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k);\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {MapIterator<any>} Key value pairs.\n   * @yields {any[]} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]];\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {MapIterator<any>} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map<any,any>): undefined} fun Function to\n   *   execute for each element, which takes a value, a key, and the Map\n   *   being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg = this) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function');\n    }\n    for (const kv of super.entries()) {\n      fun.call(thisArg, kv[1], CborMap._decode(kv[0]), this);\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {import('./encoder.js')} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false;\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]]);\n      entries.sort((a, b) => a[0].compare(b[0]));\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n\nmodule.exports = CborMap;\n"],"names":[],"mappings":"AAEA,MAAM,EAAC,MAAM,EAAC;AACd,MAAM;AACN,MAAM;AACN,MAAM,EAAC,EAAE,EAAC;AAEV;;;;;;;;;;CAUC,GACD,MAAM,gBAAgB;IACpB;;;;;;;GAOC,GACD,YAAY,QAAQ,CAAE;QACpB,KAAK,CAAC;IACR;IAEA;;;;GAIC,GACD,OAAO,QAAQ,GAAG,EAAE;QAClB,OAAO,QAAQ,eAAe,CAAC,KAAK,QAAQ,CAAC;IAC/C;IAEA;;;;GAIC,GACD,OAAO,QAAQ,GAAG,EAAE;QAClB,OAAO,QAAQ,eAAe,CAAC,KAAK;IACtC;IAEA;;;;;;;GAOC,GACD,IAAI,GAAG,EAAE;QACP,OAAO,KAAK,CAAC,IAAI,QAAQ,OAAO,CAAC;IACnC;IAEA;;;;;;;;GAQC,GACD,IAAI,GAAG,EAAE,GAAG,EAAE;QACZ,OAAO,KAAK,CAAC,IAAI,QAAQ,OAAO,CAAC,MAAM;IACzC;IAEA;;;;;;;GAOC,GACD,OAAO,GAAG,EAAE;QACV,OAAO,KAAK,CAAC,OAAO,QAAQ,OAAO,CAAC;IACtC;IAEA;;;;;;;;GAQC,GACD,IAAI,GAAG,EAAE;QACP,OAAO,KAAK,CAAC,IAAI,QAAQ,OAAO,CAAC;IACnC;IAEA;;;;;;GAMC,GACD,CAAC,OAAO;QACN,KAAK,MAAM,KAAK,KAAK,CAAC,OAAQ;YAC5B,MAAM,QAAQ,OAAO,CAAC;QACxB;IACF;IAEA;;;;;;GAMC,GACD,CAAC,UAAU;QACT,KAAK,MAAM,MAAM,KAAK,CAAC,UAAW;YAChC,MAAM;gBAAC,QAAQ,OAAO,CAAC,EAAE,CAAC,EAAE;gBAAG,EAAE,CAAC,EAAE;aAAC;QACvC;IACF;IAEA;;;;;GAKC,GACD,CAAC,OAAO,QAAQ,CAAC,GAAG;QAClB,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA;;;;;;;;;GASC,GACD,QAAQ,GAAG,EAAE,UAAU,IAAI,EAAE;QAC3B,IAAI,OAAO,QAAQ,YAAY;YAC7B,MAAM,IAAI,UAAU;QACtB;QACA,KAAK,MAAM,MAAM,KAAK,CAAC,UAAW;YAChC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC,EAAE,EAAE,QAAQ,OAAO,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI;QACvD;IACF;IAEA;;;;;GAKC,GACD,WAAW,GAAG,EAAE;QACd,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,GAAG,GAAG;YACpC,OAAO;QACT;QACA,IAAI,IAAI,SAAS,EAAE;YACjB,MAAM,UAAU,MAAM,IAAI,CAAC,KAAK,CAAC,WAC9B,GAAG,CAAC,CAAA,KAAM;oBAAC,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;oBAAW,EAAE,CAAC,EAAE;iBAAC;YAClD,QAAQ,IAAI,CAAC,CAAC,GAAG,IAAM,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACxC,KAAK,MAAM,MAAM,QAAS;gBACxB,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG;oBAC5C,OAAO;gBACT;YACF;QACF,OAAO;YACL,KAAK,MAAM,MAAM,KAAK,CAAC,UAAW;gBAChC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,cAAc,IAAI,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG;oBACnE,OAAO;gBACT;YACF;QACF;QACA,OAAO;IACT;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 3235, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/objectRecorder.js"],"sourcesContent":["'use strict';\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear();\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap();\n    this.count = 0;\n    this.recording = true;\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false;\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj);\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1];\n        }\n\n        val[0] = true;\n        return ObjectRecorder.FIRST;\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER;\n      }\n      val.push(this.count++);\n      // Second use while recording\n      return val[1];\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording');\n    }\n    this.map.set(obj, [false]);\n    // First use while recording\n    return ObjectRecorder.NEVER;\n  }\n}\n\nObjectRecorder.NEVER = -1;\nObjectRecorder.FIRST = -2;\n\nmodule.exports = ObjectRecorder;\n"],"names":[],"mappings":"AAEA;;;;;CAKC,GACD,MAAM;IACJ,aAAc;QACZ,IAAI,CAAC,KAAK;IACZ;IAEA;;GAEC,GACD,QAAQ;QACN,IAAI,CAAC,GAAG,GAAG,IAAI;QACf,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA;;GAEC,GACD,OAAO;QACL,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA;;;;;;;;;;GAUC,GACD,MAAM,GAAG,EAAE;QACT,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;QACzB,IAAI,KAAK;YACP,IAAI,IAAI,MAAM,GAAG,GAAG;gBAClB,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,CAAC,SAAS,EAAE;oBAC5B,OAAO,GAAG,CAAC,EAAE;gBACf;gBAEA,GAAG,CAAC,EAAE,GAAG;gBACT,OAAO,eAAe,KAAK;YAC7B;YACA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,OAAO,eAAe,KAAK;YAC7B;YACA,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK;YACnB,6BAA6B;YAC7B,OAAO,GAAG,CAAC,EAAE;QACf;QACA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK;YAAC;SAAM;QACzB,4BAA4B;QAC5B,OAAO,eAAe,KAAK;IAC7B;AACF;AAEA,eAAe,KAAK,GAAG,CAAC;AACxB,eAAe,KAAK,GAAG,CAAC;AAExB,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 3300, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/sharedValueEncoder.js"],"sourcesContent":["'use strict';\n\nconst Encoder = require('./encoder');\nconst ObjectRecorder = require('./objectRecorder');\nconst {Buffer} = require('buffer');\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts);\n    this.valueSharing = new ObjectRecorder();\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj);\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28);\n          break;\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break;\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared);\n      }\n    }\n    return super._pushObject(obj, opts);\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop();\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear();\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder();\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o);\n    }\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll(objs);\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} _objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(..._objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options);\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}); // Sink all writes\n    enc.pushAny(obj);\n    enc.stopRecording();\n    enc.removeAllListeners('data');\n    return enc._encodeAll([obj]);\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = [];\n      const enc = new SharedValueEncoder(options);\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {});\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.stopRecording();\n      enc.removeAllListeners('data');\n      enc.on('data', buf => bufs.push(buf));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n}\n\nmodule.exports = SharedValueEncoder;\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM,EAAC,MAAM,EAAC;AAEd;;;;CAIC,GACD,MAAM,2BAA2B;IAC/B,YAAY,IAAI,CAAE;QAChB,KAAK,CAAC;QACN,IAAI,CAAC,YAAY,GAAG,IAAI;IAC1B;IAEA;;;;;;;GAOC,GACD,YAAY,GAAG,EAAE,IAAI,EAAE;QACrB,IAAI,QAAQ,MAAM;YAChB,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;YACvC,OAAQ;gBACN,KAAK,eAAe,KAAK;oBACvB,qBAAqB;oBACrB,IAAI,CAAC,QAAQ,CAAC;oBACd;gBACF,KAAK,eAAe,KAAK;oBAEvB;gBACF;oBACE,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,CAAC,WAAW,CAAC;YACjD;QACF;QACA,OAAO,KAAK,CAAC,YAAY,KAAK;IAChC;IAEA;;GAEC,GACD,gBAAgB;QACd,IAAI,CAAC,YAAY,CAAC,IAAI;IACxB;IAEA;;;GAGC,GACD,iBAAiB;QACf,IAAI,CAAC,YAAY,CAAC,KAAK;IACzB;IAEA;;;;;;GAMC,GACD,OAAO,OAAO,GAAG,IAAI,EAAE;QACrB,MAAM,MAAM,IAAI;QAChB,6CAA6C;QAC7C,IAAI,EAAE,CAAC,QAAQ,KAAO,IAAI,kBAAkB;QAE5C,KAAK,MAAM,KAAK,KAAM;YACpB,IAAI,OAAO,CAAC;QACd;QACA,IAAI,aAAa;QACjB,IAAI,kBAAkB,CAAC;QACvB,OAAO,IAAI,UAAU,CAAC;IACxB;IAEA;;;;;;;GAOC,GACD,OAAO,gBAAgB,GAAG,KAAK,EAAE;QAC/B,MAAM,IAAI,MAAM;IAClB;IAEA;;;;;;;;GAQC,GACD,OAAO,UAAU,GAAG,EAAE,OAAO,EAAE;QAC7B,MAAM,MAAM,IAAI,mBAAmB;QACnC,6CAA6C;QAC7C,IAAI,EAAE,CAAC,QAAQ,KAAO,IAAI,kBAAkB;QAC5C,IAAI,OAAO,CAAC;QACZ,IAAI,aAAa;QACjB,IAAI,kBAAkB,CAAC;QACvB,OAAO,IAAI,UAAU,CAAC;YAAC;SAAI;IAC7B;IAEA;;;;;;;;;;;GAWC,GACD,OAAO,YAAY,GAAG,EAAE,OAAO,EAAE;QAC/B,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,qBAAqB,GACrB,MAAM,OAAO,EAAE;YACf,MAAM,MAAM,IAAI,mBAAmB;YACnC,6CAA6C;YAC7C,IAAI,EAAE,CAAC,QAAQ,KAAO;YACtB,IAAI,EAAE,CAAC,SAAS;YAChB,IAAI,EAAE,CAAC,UAAU,IAAM,QAAQ,OAAO,MAAM,CAAC;YAC7C,IAAI,OAAO,CAAC;YACZ,IAAI,aAAa;YACjB,IAAI,kBAAkB,CAAC;YACvB,IAAI,EAAE,CAAC,QAAQ,CAAA,MAAO,KAAK,IAAI,CAAC;YAChC,IAAI,OAAO,CAAC;YACZ,IAAI,GAAG;QACT;IACF;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 3425, "column": 0}, "map": {"version":3,"sources":["file:///Users/saipranav/Documents/GitHub/Cardano-Hackathon-Asia-2025/medical-dashboard-design-2/frontend/node_modules/.pnpm/cbor%4010.0.11/node_modules/cbor/lib/cbor.js"],"sourcesContent":["'use strict';\n\nconst Commented = require('./commented');\nconst Diagnose = require('./diagnose');\nconst Decoder = require('./decoder');\nconst Encoder = require('./encoder');\nconst Simple = require('./simple');\nconst Tagged = require('./tagged');\nconst Map = require('./map');\nconst SharedValueEncoder = require('./sharedValueEncoder');\n\nmodule.exports = {\n  Commented,\n  Diagnose,\n  Decoder,\n  Encoder,\n  Simple,\n  Tagged,\n  Map,\n  SharedValueEncoder,\n\n  /**\n   * Convenience name for {@linkcode Commented.comment}.\n   */\n  comment: Commented.comment,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAll}.\n   */\n  decodeAll: Decoder.decodeAll,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirst}.\n   */\n  decodeFirst: Decoder.decodeFirst,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAllSync}.\n   */\n  decodeAllSync: Decoder.decodeAllSync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decodeFirstSync: Decoder.decodeFirstSync,\n\n  /**\n   * Convenience name for {@linkcode Diagnose.diagnose}.\n   */\n  diagnose: Diagnose.diagnose,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encode}.\n   */\n  encode: Encoder.encode,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeCanonical}.\n   */\n  encodeCanonical: Encoder.encodeCanonical,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeOne}.\n   */\n  encodeOne: Encoder.encodeOne,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeAsync}.\n   */\n  encodeAsync: Encoder.encodeAsync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decode: Decoder.decodeFirstSync,\n\n  /**\n   * The codec information for\n   * {@link https://github.com/Level/encoding-down encoding-down}, which is a\n   * codec framework for leveldb.  CBOR is a particularly convenient format for\n   * both keys and values, as it can deal with a lot of types that JSON can't\n   * handle without losing type information.\n   *\n   * @example\n   * const level = require('level')\n   * const cbor = require('cbor')\n   *\n   * async function putget() {\n   *   const db = level('./db', {\n   *     keyEncoding: cbor.leveldb,\n   *     valueEncoding: cbor.leveldb,\n   *   })\n   *\n   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)\n   *   const val = await db.get({a: 1})\n   * }\n   */\n  leveldb: {\n    decode: Decoder.decodeFirstSync,\n    encode: Encoder.encode,\n    buffer: true,\n    name: 'cbor',\n  },\n\n  /**\n   * Reset everything that we can predict a plugin might have altered in good\n   * faith.  For now that includes the default set of tags that decoding and\n   * encoding will use.\n   */\n  reset() {\n    Encoder.reset();\n    Tagged.reset();\n  },\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;;GAEC,GACD,SAAS,UAAU,OAAO;IAE1B;;GAEC,GACD,WAAW,QAAQ,SAAS;IAE5B;;GAEC,GACD,aAAa,QAAQ,WAAW;IAEhC;;GAEC,GACD,eAAe,QAAQ,aAAa;IAEpC;;GAEC,GACD,iBAAiB,QAAQ,eAAe;IAExC;;GAEC,GACD,UAAU,SAAS,QAAQ;IAE3B;;GAEC,GACD,QAAQ,QAAQ,MAAM;IAEtB;;GAEC,GACD,iBAAiB,QAAQ,eAAe;IAExC;;GAEC,GACD,WAAW,QAAQ,SAAS;IAE5B;;GAEC,GACD,aAAa,QAAQ,WAAW;IAEhC;;GAEC,GACD,QAAQ,QAAQ,eAAe;IAE/B;;;;;;;;;;;;;;;;;;;;GAoBC,GACD,SAAS;QACP,QAAQ,QAAQ,eAAe;QAC/B,QAAQ,QAAQ,MAAM;QACtB,QAAQ;QACR,MAAM;IACR;IAEA;;;;GAIC,GACD;QACE,QAAQ,KAAK;QACb,OAAO,KAAK;IACd;AACF","ignoreList":[0]}}]
}